#%%
"""
Gen_XRD.py gnerates random X-ray diffraction data from irradiated crystals.
"""
import os
import concurrent.futures
import numpy as np
from scipy.optimize import leastsq
from scipy.interpolate import interp1d
from time import time
import xrayutilities as xu
from tools import f_pVoigt, f_Gauss
from def_strain import f_strain

def gen_mater(mater, order, wl = 1.5406):
        mater = xu.materials.Crystal.fromCIF(os.path.join("structures", mater))
        Vol = mater.lattice.UnitCellVolume()
        h, k, l = 0, 0, int(order)
        phi = 0.0
        d = mater.planeDistance(h, k, l)
        FH = mater.StructureFactor(mater.Q(h, k, l), 12398 / wl)
        FmH = mater.StructureFactor(mater.Q(-h, -k, -l), 12398 / wl)
        F0 = mater.StructureFactor(mater.Q(0, 0, 0), 12398 / wl)
        dic_mater = {
            "wl":wl,
            "Vol": Vol,
            "phi":phi,
            "d":d,
            "FH":FH,
            "FmH": FmH,
            "F0":F0,
        }
        return dic_mater

def gen_sp(z, t, Nspline, model):
    # generates an asymmetric gaussian. z vales close to interface are excluded

    def gen_gauss_fit(z, t, Nspline, model):
        np.random.seed()
        max = 0.01 # exact value is not important
        pos = np.random.randint(3 * t / Nspline, t) #La 1er coord possible est la 1ere spline !=0
        FWHM1 = np.random.random() * (t - t/10) + t/10
        FWHM2 = np.random.random() * (t - t/10) + t/10
        curve = f_Gauss(z, [max, pos, FWHM1])
        curve[z > pos] = f_Gauss(z[z > pos], [max, pos, FWHM2])
        # randomly add a constant (left/right/both) with random fractional height
        if np.random.random() > 0.75:
            r = np.random.random()
            frac = np.random.random()*1
            # frac = 1.0
            cst = np.zeros(len(curve))
            if r < 0.33:
                cst[z < pos] = frac * max
                curve[z < pos] = (1 - frac) * curve[z < pos] + cst[z < pos]
            elif r > 0.66:
                cst[z > pos] = frac * max
                curve[z > pos] = (1 - frac) * curve[z > pos] + cst[z > pos]
            else:
                cst = frac * max
                curve = (1 - frac) * curve + cst

        # fits B-spline to the curve to obtain the weights
        def errfunc(sp, alt, curve):
            return f_strain(alt, sp, t, model) - curve

        sp = np.zeros(Nspline + 3)
        sp_fit, success = leastsq(errfunc, sp, args=(z, curve))

        # add random variations to the weights
        delta = 0.1 * sp_fit
        sp_fit += delta * (-1 + 2*np.random.random(len(sp_fit)))

        sp_fit[sp_fit < -0.1] = 0
        return np.abs(sp_fit[3:] / sp_fit.max())

    # repeat if the first 2 spline are too small (<0.01)
    out = gen_gauss_fit(z, t, Nspline, model)
    while (out[0]<=0.01) and (out[1]<=0.01):
        out = gen_gauss_fit(z, t, Nspline, model)

    return out


# output: th, param, cst
def gen_parameters(dic_mater, order, t, scale_e, scale_dw, width, eta, bkg, scalef, randomize=True):
    """
    Generates the parameters required for XRD calculation.

    ### Parameters
    - dic_mater: dictionnary of material properties, generated by gen_mater
    - order: int. The diffraction order
    - t: float. Thickness of the irradiated region
    - scale_e: float. Scales the strain
    - scale_dw: scales the DW StructureFactor
    - width: FWHM of the resolution function

    ### Returns:
    - th: ndarray. Array of diffraction angles
    - param: ndarray. The B-spline weights + the DW scale factor
    - cst: dict. All constant parameters related to the experiment and material.
    """
    ############################ constants #####################################
    re = 2.818e-5

    model = "B-splines smooth"
    Nspline = 10  # number of bsplines
    N = 500  # numer of lamellas 1000
    nbth = 501 # number of scanning steps
    th_step = 0.005 * np.pi/180 # define scanning step (instead of fixed th values)

    b_S = -1  # asymmetry parameter
    offset = 0  # theta offset
    if randomize:
        eps1 = 0.002 + np.random.random()*(0.025-0.002) # defines the lower theta limit
        eps2 = 0.002 + np.random.random()*(0.025-0.002)# defines the upper theta
    else:
        eps1 = 0.01
        eps2 = 0.01

    wl = dic_mater["wl"]
    Vol = dic_mater["Vol"]
    phi = dic_mater["phi"]
    d = dic_mater["d"]
    FH = dic_mater["FH"]
    FmH = dic_mater["FmH"]
    F0 = dic_mater["F0"]
    ############################################################################
    t = t * 10  # irradiated thickness in Angstroms
    width = width * np.pi / 360  # width of resolution function in radians
    h, k, l = 0, 0, int(order)
    G = re * wl * wl / (np.pi * Vol)
    thB_S = np.arcsin(wl / (2 * d))

    # generate the th range: lower is determined by strain + eps1 -> th
    truestrain = scale_e / 100
    thmin = (thB_S - (truestrain + eps1) * np.tan(thB_S))*180/np.pi
    thmax = (thB_S + eps2 * np.tan(thB_S)) * 180/np.pi
    # round to 2 digits and convert back to rads
    thmin = round(thmin,2) * np.pi/180
    thmax = round(thmax,2) * np.pi/180
    
    th = np.arange(thmin, thmax, th_step)
    resol = f_pVoigt(th, [1, (th.min() + th.max()) / 2, width, eta])

    # generate the strain parameters -> param
    t_l = t / N
    z = np.arange(N + 1) * t_l

    if randomize:
        sp = gen_sp(z, t, Nspline, "B-splines abrupt") * scale_e
    else:
        sp = np.ones(Nspline) * scale_e

    param = np.ones(Nspline + 1)
    param[:Nspline] = sp 
    param[-1] = scale_dw

    cst = {
        "d": d,
        "offset": offset,
        "G": G,
        "thB_S": thB_S,
        "wl": wl,
        "t": t,
        "N": N,
        "resol": resol,
        "b_S": b_S,
        "phi": phi,
        "t_l": t_l,
        "z": z,
        "FH": FH,
        "FmH": FmH,
        "F0": F0,
        "sdw_basis": Nspline,
        "sdw_model": model,
        "bkg": bkg,
        "scalef": scalef,
    }

    return th, param, cst

def XRD(th, param, cst, add_noise = False):
    offset = cst["offset"] * np.pi / 360
    G = cst["G"]
    thB_S = cst["thB_S"]
    wl = cst["wl"]
    t = cst["t"]
    N = cst["N"]
    resol = cst["resol"]
    b_S = cst["b_S"]
    phi = cst["phi"]
    t_l = cst["t_l"]
    z = cst["z"]
    FH = cst["FH"]
    FmH = cst["FmH"]
    F0 = cst["F0"]
    Nspline = cst["sdw_basis"]
    model = cst["sdw_model"]
    bkg = cst["bkg"]
    scalef = cst["scalef"]

    th = th + offset
    strain = f_strain(z, param[:Nspline:], t, model)

    # The DW is assumed to scale with strain / the strain is normalized
    # so as to be comparable for different curves with different strain
    # DW = np.exp(-param[-1] * ((strain / strain.max()) ** 2)
    DW = np.exp(-param[-1] * ((strain / strain.max()) ** 2) )
    
    thB = thB_S - strain * np.tan(thB_S)

    eta = (-b_S * (th - thB_S) * np.sin(2 * thB_S) - 0.5 * G * F0 * (1 - b_S)) / (
        (abs(b_S) ** 0.5) * G * (FH * FmH) ** 0.5
    )
    res = eta - np.sign(eta.real) * ((eta * eta - 1) ** 0.5)

    n = 1
    while n <= N:
        g0 = np.sin(thB[n] - phi)
        gH = -np.sin(thB[n] + phi)
        b = g0 / gH
        T = np.pi * G * ((FH * FmH) ** 0.5) * t_l * DW[n] / (wl * (abs(g0 * gH) ** 0.5))
        eta = (-b * (th - thB[n]) * np.sin(2 * thB_S) - 0.5 * G * F0 * (1 - b)) / (
            (abs(b) ** 0.5) * G * DW[n] * (FH * FmH) ** 0.5
        )
        sqrt_eta2 = (eta * eta - 1) ** 0.5

        S1 = (res - eta + sqrt_eta2) * np.exp(-1j * T * sqrt_eta2)
        S2 = (res - eta - sqrt_eta2) * np.exp(1j * T * sqrt_eta2)

        res = eta + sqrt_eta2 * ((S1 + S2) / (S1 - S2))
        n += 1

    ical = np.convolve(abs(res) ** 2, resol, mode="same") #resolution

    ical /= ical.max() # normalize to unity
    ical *= scalef # set maximum intensity
    ical += bkg # add background

    if add_noise:
        np.random.seed()
        ical += np.random.poisson(ical)

    return ical

# outputs scaled abscissae and intensity: x_new, i_new
# Input data must be between 1 and max
def rescale_XRD(th, i_old, cst, data_size = "long", experimental=False):
    # convert angles to strain
    if experimental == False:
        dsp = cst["wl"] / (2 * np.sin(th))
        dB = cst["wl"] / (2 * np.sin(cst["thB_S"]))
        e = 100 * (dsp - dB) / dB
    else:
        dsp = cst["wl"] / (2 * np.sin(th))
        thmax = th[i_old == i_old.max()]
        dB = cst["wl"] / (2 * np.sin(thmax))
        e = 100 * (dsp - dB) / dB

    # fill_value = 1
    fill_value = i_old[np.nonzero(i_old)].min()
    i_old = np.where(i_old==0, fill_value, i_old) #remove any 0's

    # convert strain to rescaled strain
    x_old = e / cst["d"]
    f_interp = interp1d(
        x_old, i_old, kind="linear", fill_value=fill_value, bounds_error=False
    )
    if data_size == "long":
        x_new = np.linspace(8, -1, 1001)
    elif data_size == "short":
        x_new = np.linspace(3, -1, 401)
    else:
        raise ValueError('Wrong data size')

    i_new = f_interp(x_new)
    norm_factor = i_new.max()
    i_new /= norm_factor
    i_new = np.log10(i_new)

    return x_new, i_new

def XRDfromNN(dic_mater, order, width, eta, bkg, scalef, labels, data_size):
    param = labels[:11]
    t = labels[11]
    th, _ , cst = gen_parameters(dic_mater, order, t, 8, 0, width, eta, bkg, scalef, randomize=False)
    ical = XRD(th, param, cst, add_noise=False)
    x_new, i_new = rescale_XRD(th, ical, cst, data_size, experimental=True)
    return x_new, i_new

def XRDfromEXP(exp_data, dic_mater, order, data_size):
    _, param, cst = gen_parameters(dic_mater, order, 100, 8, 0, 0.01, 0.001, 0, 1e5, randomize=False)
    x_old = exp_data[:,0]*np.pi/360
    i_old = exp_data[:,1]
    x_new, i_new = rescale_XRD(x_old, i_old, cst, data_size, experimental=True)
    return x_new, i_new

if __name__ == '__main__':
    
    mater = "ZrO2.cif"
    order = 4
    ii = 0
    dic_mater = gen_mater(mater, order)

    def procedure_all_random(t):
        ii = 0
        # for _ in range(15625):
        for _ in range(32895):    
            np.random.seed()
            print(os.getpid(), ii)

            # scale_e = 0.2 + np.random.random()*(8-0.2)
            # scale_e = 0.5 + np.random.random()*(8-0.5)
            scale_e = 0.5 + np.random.random()*(2-0.5)

            # without thickness in DW
            # scale_dw = -np.log(0.001 + (1-0.001)*np.random.random()) #log(1)=0, log(0.001)=-6.9
            scale_dw = -np.log(0.05 + (1-0.05)*np.random.random()) #log(1)=0, log(0.001)=-6.9
            # with thickness in DW
            # scale_dw = -np.log(0.05 + (1-0.05)*np.random.random()) #log(1)=0, log(0.05)=-3
            fwhm = 0.003 + np.random.random() * 0.097
            # eta = 0.0001 + np.random.random() * (0.02 - 0.0001)
            eta = 0.001 # fixed quasi-Gaussian
            bkg = 10**(np.random.random()*1.7)
            scalef = 10**(3 + np.random.random()*(7-3))#10**(3.7 + np.random.random()*(7-3.7))
            dyn = np.log10(scalef/bkg)
            
            while (dyn<=3) or (dyn>=6):
                print("WARNING dyn =:", dyn)
                bkg = 10**(np.random.random()*1.7)
                scalef = 10**(3 + np.random.random()*(7-3))
                dyn = np.log10(scalef/bkg)


            th, param, cst = gen_parameters(
                dic_mater, order, t, scale_e, scale_dw, fwhm, eta, bkg, scalef, randomize=True
                )
            i_cal = XRD(th, param, cst, add_noise=True)
            x_new, i_new = rescale_XRD(th, i_cal, cst, data_size="short", experimental=False)

            param = np.append(param, [t, fwhm, dyn])

            t0 = abs(hash(str(time()) + str(os.getpid())))

            np.savetxt(NAME + "label." + str(t0) + ".txt", param)
            np.savetxt(NAME + "data." + str(t0) + ".txt", i_new)

            ii += 1
    
        
    NAME = "DATA PATH HERE"
    try:
        print("Creating destination folder")
        os.mkdir(NAME)
    except:
        print("Folder already exists")
    
    t0 = time()
    with concurrent.futures.ProcessPoolExecutor() as executor:
        # for t in executor.map(procedure_all_random, range(50, 1010, 10)):
        for t in executor.map(procedure_all_random, range(100, 1060, 10)):
            print("done")
    print("Generation time: ",(time() - t0)/3600 ) 


# %%



